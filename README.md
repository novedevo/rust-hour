# Rust Hour


As is tradition in the Rust community, this is a rewrite of a project originally in a different language. As is also tradition, this rewrite resulted in a 10x performance improvement instantly, without any optimizations. After performance optimization, this program can solve all 35 test cases, and output the solved boards, in as little as 0.04 seconds on a Ryzen 5 3600. This is a result of various coding choices, but it is in no small part thanks to the aggressive optimization of the Rust compiler as well.

As with the Java version, our graph traversal algorithm was actually unimportant. Depth-first search performs better than breadth-first search, and A* with a basic heuristic lands in the middle. However, this is the difference between checking ~100k board states and ~70k states: not actually all that much.

One of the most relevant performance decisions was the way we kept track of which states we had visited. If this was not done at all, the program gets stuck in loops and never (?) terminates. We add tens of thousands of board states to it, and need to check if it contains many times that. The obvious choice is a HashMap, as it supports (theoretically) O(1) insertion and contains() checking. This worked, but upon profiling our executable with valgrind's Callgrind, we discovered that the majority of our program's runtime was being consumed by hashing operations. Our initial response was to switch to a BTreeMap, as those theoretically offer consistently better performance, but that requires ordering, and making that many comparisons actually slowed the program down tenfold. Upon further reading, I found that Rust's default hashing algorithm is SipHash, which is cryptographically secure and resistant to multiple forms of hash attacks, but isn't as fast as alternatives. Since cryptography was of no concern to this program, we looked for a better one, and found it in aHash. This crate (Rust's term for an importable third-party module, like you might find on Python's `pip`) purported to be the fastest algorithm available, and it maintained some resistance to attacks such as hashDOS. These claims had validity, 
